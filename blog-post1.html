<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Implementing A* Pathfinding for Smarter Game AI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: #1a1a1a;
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
            position: relative;
            overflow-x: hidden;
        }
        
        /* Background canvas for particles */
        #particles-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
        
        .container {
            background-color: rgba(42, 42, 42, 0.85);
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            padding: 40px;
            max-width: 800px;
            margin: 40px auto;
            backdrop-filter: blur(5px);
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
        }
        
        h1 {
            font-size: 28px;
            margin-bottom: 20px;
            color: #e3b87d;
        }
        
        h2 {
            font-size: 22px;
            margin: 30px 0 15px;
            color: #e3b87d;
        }
        
        h3 {
            font-size: 18px;
            margin: 25px 0 10px;
            color: #d0d0d0;
        }
        
        p {
            font-size: 16px;
            color: #d0d0d0;
            margin-bottom: 20px;
        }
        
        /* Navigation styles */
        .nav {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .nav-link {
            display: inline-block;
            padding: 6px 12px;
            margin: 0 5px;
            color: #e3b87d;
            text-decoration: none;
            border-bottom: 2px solid transparent;
            transition: all 0.3s ease;
        }
        
        .nav-link:hover, .nav-link.active {
            border-bottom: 2px solid #e3b87d;
        }
        
        /* Blog post styles */
        .post-meta {
            font-size: 14px;
            color: #a98d6d;
            margin-bottom: 30px;
            text-align: center;
        }
        
        .tag {
            display: inline-block;
            font-size: 12px;
            padding: 3px 8px;
            margin-right: 5px;
            background-color: rgba(169, 141, 109, 0.2);
            border: 1px solid #a98d6d;
            border-radius: 4px;
            color: #a98d6d;
        }
        
        .back-link {
            display: inline-block;
            margin-top: 30px;
            color: #a98d6d;
            text-decoration: none;
            transition: color 0.3s ease;
        }
        
        .back-link:hover {
            color: #e3b87d;
        }
        
        pre {
            background-color: rgba(30, 30, 30, 0.8);
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 20px 0;
            border-left: 3px solid #e3b87d;
        }
        
        code {
            font-family: 'Courier New', Courier, monospace;
            color: #d4d4d4;
        }
        
        .image-container {
            margin: 25px 0;
            text-align: center;
        }
        
        .pseudocode {
            font-family: 'Courier New', Courier, monospace;
            padding: 15px;
            background-color: rgba(30, 30, 30, 0.8);
            border-radius: 5px;
            margin: 20px 0;
            white-space: pre-wrap;
            border-left: 3px solid #e3b87d;
        }
        
        .note {
            background-color: rgba(227, 184, 125, 0.1);
            border-left: 3px solid #e3b87d;
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 5px 5px 0;
        }
        
        .navigation-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid rgba(227, 184, 125, 0.3);
        }
    </style>
</head>
<body>
    <canvas id="particles-canvas"></canvas>
    
    <div class="container">
        <div class="header">
            <div class="nav">
                <a href="index.html" class="nav-link">Home</a>
                <a href="blog.html" class="nav-link">Blog</a>
            </div>
            <h1>Implementing GOAP For AI Agents</h1>
            <div class="post-meta">May 2, 2025 · 5 min read · <span class="tag">Game AI</span></div>
        </div>
        
        <p>
            AI agents are the spice that bring many games to life. They provide a reactive challenge to players, forcing them to be adaptive and smart in how they pick fights. In the best case scenarios at least. At their worst, enemy AI can be boring and actually detract from a game's fun. So, how do we build fun, reactive, and intelligent AI for out games?
        </p>       
        
        <h2>What's a GOAP?</h2>
        
        <p>
            GOAP is an acronym that stands for Goal Oriented Action Planning, and it's that last word that makes GOAP so interesting, even some 20 years after the technology was unvealed for the game F.E.A.R. 
        </p>
        
        <h2>Why is Planning Special?</h2>
        
        <p>
            Unlike GOAP, most AI systems are actually incapable of forming plans. This is because they're built using what are known as "Behavior Trees." These systems utilize fixed connections between the actions an agent can perform in order to accomplish it's goals, these action / goal pairings are also called Behaviors. As an easy example, let's say we have an AI agent with a sword. When it sees the player, it will likely trigger it's "Attack_With_Melee" behavior, which tells the agent to run up to the player and hit them with their sword. Within a Behavior Tree, these are fixed. So, unless a different behavior is triggered, that exact sequence of actions is what the AI will do.
        </p>

        <h2>This is where Planning comes in.</h2>
        
        <p>
            GOAP on the other hand, is capable of planning, and is actually one of a variety of AI systems known as "planning systems." When a GOAP agent decides to do something, it goes through several steps. First, it determines what it needs to do (it finds a goal). Then, the agent looks at what is supposed to happen when it reaches it's goal, and compares that against what things are like currently (it looks at the world-state, and compares it to the current world-state). Finally, the AI then looks over all the things it can do (actions), and builds a plan that uses it's actions to incrementally accomplish it's goal. Kind of like a person! What's really cool about this though, it that it means agents have totally free reign to accomplish it's goals, within the limits of the software obviously.
        </p>
        
        <div class="navigation-buttons">
            <a href="blog.html" class="back-link">← All Blog Posts</a>
            <!--<a href="blog-post2.html" class="back-link">Next Post: Optimizing Entity Component Systems →</a>-->
        </div>
    </div>

    <script>
        // Background particles script
        (function() {
            const canvas = document.getElementById('particles-canvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas dimensions to match window
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            // Particle class
            class Particle {
                constructor() {
                    this.reset();
                }
                
                reset() {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() * canvas.height;
                    this.size = Math.random() * 2 + 0.5;
                    this.speed = Math.random() * 0.5 + 0.1;
                    this.angle = Math.random() * 360;
                    this.color = Math.random() > 0.85 ? 
                                 'rgba(227, 184, 125, ' + (Math.random() * 0.35 + 0.1) + ')' : 
                                 'rgba(150, 150, 150, ' + (Math.random() * 0.15 + 0.05) + ')';
                    this.opacity = Math.random() * 0.5 + 0.1;
                }
                
                update() {
                    this.x += Math.cos(this.angle * Math.PI / 180) * this.speed;
                    this.y += Math.sin(this.angle * Math.PI / 180) * this.speed;
                    
                    // Change angle slightly for meandering effect
                    this.angle += Math.random() * 2 - 1;
                    
                    // Reset particles that move off-screen
                    if (this.x < -10 || this.x > canvas.width + 10 || this.y < -10 || this.y > canvas.height + 10) {
                        this.reset();
                    }
                }
                
                draw() {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                }
            }
            
            // Create particles array
            const particlesArray = [];
            const particleCount = Math.min(window.innerWidth / 10, 100); // Responsive particle count
            
            for (let i = 0; i < particleCount; i++) {
                particlesArray.push(new Particle());
            }
            
            // Animation loop
            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                for (let i = 0; i < particlesArray.length; i++) {
                    particlesArray[i].update();
                    particlesArray[i].draw();
                }
                
                requestAnimationFrame(animate);
            }
            
            animate();
        })();
    </script>
</body>
</html>